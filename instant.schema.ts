import { i } from '@instantdb/react-native';

const schema = i.schema({
  entities: {
    cards: i.entity({
      ownerId: i.string().indexed(),
      noteId: i.string().optional().indexed(),
      cardOrdinal: i.number().optional(),
      deckName: i.string().optional(),
      title: i.string(),
      frontText: i.string(),
      backText: i.string(),
      imageUris: i.json().optional(),
      isSuspended: i.boolean().optional(),
      buriedUntilDay: i.number().optional().indexed(),
      reviewState: i.string().optional(),
      dueAt: i.number().indexed().optional(),
      stability: i.number().optional(),
      difficulty: i.number().optional(),
      elapsedDays: i.number().optional(),
      scheduledDays: i.number().optional(),
      learningSteps: i.number().optional(),
      reps: i.number().optional(),
      lapses: i.number().optional(),
      lastReviewAt: i.number().optional(),
      createdAt: i.number().indexed(),
      updatedAt: i.number().indexed(),
    }),
    decks: i.entity({
      ownerId: i.string().indexed(),
      title: i.string().indexed(),
      subtitle: i.string().optional().indexed(),
      description: i.string().optional(),
      coverImageUri: i.string().optional(),
      ownerDisplayName: i.string().optional().indexed(),
      categoryId: i.string().indexed(),
      isPublished: i.boolean().indexed(),
      publishedAt: i.number().optional().indexed(),
      cardCount: i.number().indexed(),
      downloadsCount: i.number().indexed(),
      likesCount: i.number().indexed(),
      savesCount: i.number().indexed(),
      averageRating: i.number().indexed(),
      ratingCount: i.number().indexed(),
      trendingScore: i.number().indexed(),
      recommendedScore: i.number().indexed(),
      createdAt: i.number().indexed(),
      updatedAt: i.number().indexed(),
    }),
    settings: i.entity({
      ownerId: i.string().indexed().unique(),
      profileName: i.string().optional(),
      avatarPath: i.string().optional(),
      dailyReviewGoal: i.number().optional(),
      reviewSessionLimit: i.number().optional(),
      learnSessionLimit: i.number().optional(),
      learnNewCardsPerSession: i.number().optional(),
      updatedAt: i.number().indexed(),
    }),
    deckStudyOptions: i.entity({
      ownerId: i.string().indexed(),
      deckName: i.string().indexed(),
      newPerDay: i.number().optional(),
      reviewPerDay: i.number().optional(),
      newOrder: i.string().optional(),
      reviewOrder: i.string().optional(),
      burySiblings: i.boolean().optional(),
      learningSteps: i.json().optional(),
      relearningSteps: i.json().optional(),
      maxInterval: i.number().optional(),
      desiredRetention: i.number().optional(),
      easyBonus: i.number().optional(),
      intervalModifier: i.number().optional(),
      updatedAt: i.number().indexed(),
    }),
    dailyDeckStates: i.entity({
      ownerId: i.string().indexed(),
      deckName: i.string().indexed(),
      dayStamp: i.string().indexed(),
      newShown: i.number().optional(),
      reviewShown: i.number().optional(),
      customNewDelta: i.number().optional(),
      customReviewDelta: i.number().optional(),
      lastResetAt: i.number().optional(),
      updatedAt: i.number().indexed(),
    }),
    reviewEvents: i.entity({
      ownerId: i.string().indexed(),
      cardId: i.string().indexed(),
      rating: i.string().indexed(),
      reviewedAt: i.number().indexed(),
      createdAt: i.number().indexed(),
    }),
  },
  links: {
    decksCards: {
      forward: {
        on: 'decks',
        has: 'many',
        label: 'cards',
      },
      reverse: {
        on: 'cards',
        has: 'one',
        label: 'deck',
      },
    },
  },
});

export default schema;
